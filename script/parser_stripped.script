{{BEGIN_REPLACE}}

global values = ""
global op = ""
global result = ""
global service = ""
global quote = " "
global x = 0.0

### bool json_checkKeywordMatch(src="", target="", index=1)
### check if a given name in src is a valid identifier
### This is checked by testing for a prepositioned and a postpositioned quote + colcon
### src: string in which to check if a target is a valid identifier
### target: identifier key
### index: position of first character of target in src
def json_checkKeywordMatch(src="", target="", index=1):
  textmsg("check match in: ", src)
  textmsg("check for: ", target)
  textmsg("from position: ", index)

  src_length = str_len(src)
  tgt_length = str_len(target)
  if tgt_length == 0:
    textmsg("target empty!")
    return False
  end
  if src_length == 0:
    textmsg("src empty!")
    return False
  end
  if index <= 0:
    textmsg("index to low!", index)
    return False
  end
  if index + tgt_length + 1 > src_length:
    textmsg("index to high!", index)
    return False
  end

  # TODO: check for missing backslash before prepositioned quote if index is high enough
  if str_at(src,index-1) != quote:
    textmsg("keyword not headed by a quote!")
    return False
  end
  if str_at(src, index + tgt_length) != quote:
    textmsg("keyword not followed by a quote!")
    return False
  end
  if str_at(src, index + tgt_length + 1) != ":":
    textmsg("keyword not followed by a colcon!")
    return False
  end

  return True
end

### int json_strFindFirstNotOf(src, target, start = 0)
### find first character in src that is not in target
### src: string in which to look for characters
### target: string with allowed characters
### start: first character to check in src
### return position of first character not in target. if none is found return -1
def json_strFindFirstNotOf(src, target, start = 0):
  position = start
  while position < str_len(src):
    a = str_at(src, position)
    if str_find(target, a) == -1:
      return position
    end
    position = position + 1
  end
  return -1
end

### int json_findCorrespondingClosingContainer(src, open_sign, closing_sign, start=1)
### with a defined character to open a container and one to close it look for the end of the container
### src: string where to look for delimiters
### open_sign: character to open a container
### closing_sign: character to close a container
### start: first character to check in src
### return position of closing character in src. -1 if none is found
def json_findCorrespondingClosingContainer(src, open_sign, closing_sign, start=1):
  # textmsg("look for Closing Container. start: ", start)
  # textmsg("opening: ", open_sign)
  # textmsg("closing: ", closing_sign)
  position = start
  brace_count = 0
  
  while position < str_len(src):
    if str_at(src, position) == open_sign and str_at(src, position -1) != "\":
      # textmsg("found an opening at ", position)
      brace_count = brace_count + 1
    end
    
    if str_at(src, position) == closing_sign and str_at(src, position -1) != "\":
      brace_count = brace_count - 1
      # textmsg("found a closing at ", position)
      if brace_count == 0:
        # textmsg("found closing for the container at ", position)
        return position
      end
    end
    
    position = position + 1
  end
  
  textmsg("no closing container found for opening at ", start)
  return -1
end

### int json_findCorrespondingDelimiter(src, start = 0)
### Look for a following corresponding Delimiter in a Json string.
### src: json string to evaluate
### start: position of delimiter to look for a corresponding element
### return: position of character closing the container
def json_findCorrespondingDelimiter(src, start = 0):
  # textmsg("find corresponding delimiter. start ", start)
  if str_empty(src) == True:
    textmsg("Cannot find a corresponding delimiter in empty string")
    return -1
  end
  
  local length = str_len(src)
  local delimiter_start = str_at(src, start)
  local delimiter_end = " "
  
  if delimiter_start == quote:
    delimiter_end = quote
  elif delimiter_start == "{":
    delimiter_end = "}"
  elif delimiter_start == "[":
    delimiter_end = "]"
  elif delimiter_start == "(":
    delimiter_end = ")"
  else:
    # boolean expressions without quotes
    position = json_strFindFirstNotOf(src, "truefalsn", start +1)
    return position
  end
  
  return json_findCorrespondingClosingContainer(src, delimiter_start, delimiter_end, start)
end

### int[4] json_getElement
### return positions of an Element in a json string
### inp_string: json to extract the element from
### name: identifier of the element
### return: [pos of quote befor identifier, pos of quote after identifier, begin of value, end of value]
def json_getElement(inp_string, name):
  if str_empty(inp_string) == True:
    textmsg("Can not evaluate empty json string. abort")
    return [0, 0, 0, 0]
  end
  if str_empty(name) == True:
    textmsg("Empty json identifier to look for. abort")
    return [0, 0, 0, 0]
  end

  inp_length = str_len(inp_string)
  name_length = str_len(name)
  # textmsg("input_length = ", inp_length)
  # textmsg("name_length = ", name_length)

  local start_element = 0
  local begin_value = 0
  local end_element = 0
  local index = 0

  while index < inp_length:
    textmsg("startelement: ", index)
    index = str_find(inp_string, name, start_element)
    if json_checkKeywordMatch(inp_string, name, index) == True:
      start_element = index
      break
    end

    if index == -1:
      return [0, 0, 0, 0]
    end

    index = index + 1
  end

  # textmsg("found element at: ", start_element)
  
  end_element = start_element + name_length + 1
  # textmsg("end_element in step1: ", end_element)
  
  begin_value = json_strFindFirstNotOf(inp_string, ": ", end_element)
  # textmsg("end_element in step2: ", begin_value)
  if begin_value == -1:
    textmsg("did not find begin of value")
    return [0, 0, 0, 0]
  end
  
  end_element = json_findCorrespondingDelimiter(inp_string, begin_value)
  # textmsg("end_element in step3: ", end_element)
  if end_element == -1:
    textmsg("did not find end of element")
    return [0, 0, 0, 0]
  end
  
  start_element = start_element -1
  return [start_element, start_element + name_length + 2, begin_value, end_element]
end

def ri_reduceString(inp_string="", start=0, length=0):
  before = str_sub(inp_string, 0, start -1)
  after = str_sub(inp_string, start + length)
  return str_cat(before, after)
end

def ri_getValues(inp_string):
  textmsg("get values from ", inp_string)
  # local bounds = json_getElement(inp_string, "values")
  # return str_sub(inp_string, bounds[2], bounds[3]-bounds[2]+1)
  return json_getElement(inp_string, "values")
end

def ri_parseServiceResponse(inp_msg=""):
  if str_empty(inp_msg) == True:
    textmsg("no string to parse!")
    return None
  end
  
  # TODO: it is a dirty hack to get quote from json string
  quote = str_at(inp_msg, 1)
  textmsg("quote is: ", quote)
  
  local bounds = [0, 0, 0, 0]
  local msg = inp_msg
  # values = ri_getValues(msg)
  bounds = ri_getValues(msg)
  values = str_sub(msg, bounds[2], bounds[3]-bounds[2]+1)
  msg = ri_reduceString(msg, bounds[0], bounds[3])
  
  textmsg("rest: ", msg)
  
  textmsg("value = ", values)
end

###################
# START EXECUTION #
###################

socket_open("192.168.0.71", 9090, "rosbridge")

socket_send_byte(123, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(111, "rosbridge") 
socket_send_byte(112, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(58 , "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(99 , "rosbridge") 
socket_send_byte(97 , "rosbridge") 
socket_send_byte(108, "rosbridge") 
socket_send_byte(108, "rosbridge") 
socket_send_byte(95 , "rosbridge") 
socket_send_byte(115, "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(114, "rosbridge") 
socket_send_byte(118, "rosbridge") 
socket_send_byte(105, "rosbridge") 
socket_send_byte(99 , "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(44 , "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(115, "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(114, "rosbridge") 
socket_send_byte(118, "rosbridge") 
socket_send_byte(105, "rosbridge") 
socket_send_byte(99 , "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(58 , "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(47 , "rosbridge") 
socket_send_byte(115, "rosbridge") 
socket_send_byte(105, "rosbridge") 
socket_send_byte(109, "rosbridge") 
socket_send_byte(112, "rosbridge") 
socket_send_byte(108, "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(83 , "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(114, "rosbridge") 
socket_send_byte(118, "rosbridge") 
socket_send_byte(105, "rosbridge") 
socket_send_byte(99 , "rosbridge") 
socket_send_byte(101, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(44 , "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(97 , "rosbridge") 
socket_send_byte(114, "rosbridge") 
socket_send_byte(103, "rosbridge") 
socket_send_byte(115, "rosbridge") 
socket_send_byte(34 , "rosbridge") 
socket_send_byte(58 , "rosbridge") 
socket_send_byte(123, "rosbridge") 
socket_send_byte(125, "rosbridge") 
socket_send_byte(125, "rosbridge") 
socket_send_byte(10 , "rosbridge")

sleep(0.1)
string_from_server = socket_read_string("rosbridge")
ri_parseServiceResponse(string_from_server)
socket_close("rosbridge")
